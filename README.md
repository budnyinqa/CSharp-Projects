# CSharp-Projects
This repository contains three projects, each representing a different stage of my learning journey. The first project begins at level zero, designed as a very beginner-friendly application. By the third project, I was applying object-oriented programming principles and utilizing all the skills I had acquired up to that point.

Working on these projects greatly improved my understanding of how to build user-friendly applications and helped me develop a structured approach to software design.



## Number Guessing Game - Project 1
The purpose of this project was straightforward - to create a simple console game. The player’s task is to guess a number randomly generated by the program. The application provides hints by telling the user whether their guess is lower or higher than the target number. The number of attempts is recorded and displayed at the end of the game.

Even though this project is not very advanced, I decided to include it here to document the beginning of my C# journey. I built it after just one month of learning, and it made the learning process both fun and motivating.


### Generating a Random Number and Asking for Input
The full application is implemented entirely within the `Main` method. At the very beginning, a target number is created using the `Random` class. Immediately after generating the number, the program prints a welcome message and instructions, setting the stage for the interactive game, and prepares a list to store all player attempts, enabling later review of guesses.
```C#
static void Main(string[] args)
{
    Random randomizer = new Random();
    int random_number = randomizer.Next(0, 5000);

    Console.WriteLine("Hello! Welcome to the number guessing game. Your task is to find a number between 0 and 5000.\nHave Fun :)\n");
    List<int> attempts = new List<int>();
```


### Game Logic
After displaying the welcome message, the player is asked to enter a number. This happens inside a for loop, so if the guess is incorrect, the program continues to ask for another input.

Next, the program verifies whether the input is a valid number. If it is not, an appropriate error message is displayed on the screen:
```C#
for (; ; )
{
    Console.WriteLine("Enter a number:");
    int input_number;
    if (!int.TryParse(Console.ReadLine(), out input_number))
    {
        Console.ForegroundColor = ConsoleColor.Red;
        Console.WriteLine("\nYou entered a text value. Please try with an integer.");
        Console.ResetColor();
        continue;
    }
```

The last set of `if` statements checks whether the player’s guess is larger, smaller, or equal to the target number. Depending on the comparison, the program responds with a hint or a congratulatory message.
```C#
                if (input_number > random_number)
                {
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.WriteLine("\nThe target number is smaller. Try another value.");
                }

                else if (input_number < random_number)
                {
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.WriteLine("\nThe target number is larger. Try another value.");
                }

                if (input_number == random_number)
                {
                    Console.ForegroundColor = ConsoleColor.Green;
                    Console.WriteLine($"\nCongratulations!!!\n{random_number} is the correct value.\nYou guessed it after {attempts.Count} tries, that’s an amazing result!\n");
                    Console.ResetColor();
                    Console.WriteLine($"Here are all your attempts:");
                    attempts.ForEach(attempt => Console.WriteLine(attempt));
                    break;
                }

                Console.ResetColor();

            }
```
Even though the app runs in the console, I wanted it to look good. Therefore, messages are displayed in green or red, depending on their meaning: red for warnings or hints, and green for success or congratulatory messages.

This structure ensures the game provides real-time feedback, guiding the player towards the correct number while keeping track of all attempts for review.


### Output
https://github.com/user-attachments/assets/d3c2042e-1a44-4888-8880-fe7057fed87c



## Currency Converter - Project 2
The purpose of this project was to create a currency converter in the form of a `Windows Forms` application. All objects had to be placed using the designer and assigned appropriate properties. The calculation logic was kept simple, as the exchange rates were stored inside an array. Additionally, the program includes several useful features: a clear button to reset values, a swap button to quickly change the conversion direction, a scroll bar to help select the amount, and a round value checkbox to simplify the output.

Although it is a relatively simple project, it demonstrates my ability to structure code, use arrays effectively, and implement practical UI elements in `Windows Forms`. This project also helped me strengthen my understanding of event-driven programming and the fundamentals of building user-friendly desktop applications.


### Designer
I decided to keep the project minimalistic by using only two primary colors, two fonts, and a picture box to display a custom icon. While placing the individual objects, I assigned each of them a unique name and added events whenever necessary.
<img width="1207" height="788" alt="Image" src="https://github.com/user-attachments/assets/563258e9-6905-4b9c-a9a3-8ea82a5a0441" />


### Initialization and Setup
The application begins its execution with the initialization of the main form. A boolean flag `isInitializing` is declared and set to true to indicate that the form is still being set up. This flag is used throughout the code to prevent unnecessary execution of conversion logic while the user interface is not fully initialized. The application sets default values for the input fields and dropdowns. Specifically, the amount textbox `EnterAmount` is initialized to "1", while the source currency dropdown `From` selects the second currency, and the target currency dropdown `To` selects the first currency.
```C#
 public Form1()
 {
     InitializeComponent();

     EnterAmount.Text = "1"; // Sets default value for the amount input
     From.SelectedIndex = 1; // Select the second currency by default
     To.SelectedIndex = 0; // Select the first currency by default

     AmountScrollBar.Scroll += AmountScrollBar_Scroll; // Attach scroll event handler to AmountScrollBar

     isInitializing = false;

     UpdateConversion(); // Perform an conversion update
 }
```
The scrollbar is connected to an event handler to ensure that any change in the scrollbar updates the input amount dynamically. Finally, after the initialization is complete, the `isInitializing` flag is set to false, and the initial conversion is calculated by calling `UpdateConversion()`.


### Currency Convertion Logic
The exchange rates are stored in a two-dimensional array called `exchange_rate`. Each row of this array represents the source currency, while each column corresponds to the target currency.
```C#
private readonly decimal[,] exchange_rate = new decimal[,] // 2D array storing exchange rates between different currencies
{
    {1.0m, 4.25126m, 1.03717m},
    {0.235224m, 1.0m, 0.243978m},
    {0.964161m, 4.10505m, 1.0m}
};
```
To perform the conversion, the method `ConvertCurrency` takes an amount along with the source and target currency indexes. It retrieves the relevant rate from the array and multiplies the amount by this rate.
```C#
private decimal ConvertCurrency(decimal amount, int fromCurrency, int toCurrency)
{
    decimal rate = exchange_rate[fromCurrency, toCurrency]; // Get the exchange rate from the table
    return amount * rate; // Multiply the amount by the rate
}
```
The `UpdateConversion` method orchestrates the process of reading the input, validating it, performing the conversion, rounding the result if requested, and updating the user interface. It first checks the `isInitializing` flag and returns immediately if the form is still being set up. The method then tries to parse the value from `EnterAmount`. If parsing fails, an error message is displayed to the user. 

Using `ConvertCurrency`, the converted value is calculated. If the user has selected the rounding option by the checkbox, the amount is rounded to two decimal places. Finally, the converted value is displayed in the `result2` label, which is horizontally centered on the form, and the conversion rate label is updated.
```C#
result2.Text = $"{amount}{From.Text} = {converted_amount}{To.Text}"; // Display the conversion result in the result label
// Center the result label horizontally in the form
result2.Location = new Point(
    (this.ClientSize.Width - result2.Width) / 2,
    result2.Location.Y);
```


### Interface Interactions
The application responds to several user interactions. The scrollbar movement is linked to the `AmountScrollBar_Scroll` event, which updates the amount textbox in real time. Clicking the GENERATE button triggers a conversion by calling `UpdateConversion()`. 

Users can swap the source and target currencies by clicking on a picture box, which temporarily stores the target currency index, performs the swap.
```C#
private void pictureBox1_Click(object sender, EventArgs e)
{
    int To_copy = To.SelectedIndex; // Temporarily store the target currency
    // Swap the selections
    To.SelectedIndex = From.SelectedIndex;
    From.SelectedIndex = To_copy;
}
```
Lastly, the CLEAR button resets the form by clearing the amount, deselecting both currencies, moving the scrollbar to its minimum position, and unchecking the rounding checkbox.
```C#
private void button2_Click(object sender, EventArgs e)
{
    From.SelectedIndex = -1; // Deselect "From" currency
    To.SelectedIndex = -1; // Deselect "To" currency
    EnterAmount.Text = ""; // Clear input field
    Round_checkBox.Checked = false; // Reset checkbox
    AmountScrollBar.Value = AmountScrollBar.Minimum; // Reset scrollbar to its minimum position
}
```


### Output
https://github.com/user-attachments/assets/48091bdb-56d3-45fe-bea7-42b6b1413c02



## Brick Breaker - Project 3
The goal of the project is to create a Breakout-style game, in which the player controls a paddle that bounces a ball in order to destroy all the bricks on the screen. The ball bounces off the walls, the paddle, and the bricks, destroying them upon collision, and if it falls below the bottom edge of the screen, the game ends. A demo has also been included, showing a game played automatically, where the paddle moves on its own.

The code is designed to follow all established object-oriented programming principles, including Encapsulation, Inheritance, Polymorphism, and Abstraction, as well as the Single Responsibility Principle (SRP). These rules ensure clean architecture, improved maintainability, and greater flexibility when extending or modifying the project.



### Main Menu
The first and also the easiest element to create is the main menu, from which the user decides whether they want to play the game, watch the demo, or close the application. Its primary task is therefore to initialize the graphical interface and respond to player interactions through buttons.

The menu is created in a public class that extends the `Panel` class, which means it is a part of the graphical interface. Inside the class, there are also several methods, and I would like to discuss the most important ones in the following subsections.


#### InitializeMenu method
The method is responsible for preparing and arranging the elements, buttons and header, within the panel. It first calculates the optimal proportions using the form’s dimensions to ensure that all objects are centered on the screen. The buttons are generated through a separate method created specifically for this purpose.

In addition, this method assigns actions to the individual buttons, ensuring that the entire menu is fully functional.
```C#
private void InitializeMenu() // Initialize buttons, create a label, and handle individual events
{
    // Calculate the ideal starting positions for the created buttons on the X and Y axes to keep everything centered
    int buttonWidth = 170, buttonHeight = 70, gap = 12, labelHeight = 150, labelWidth = 600;
    int totalHeight = labelHeight + buttonHeight * 2 + gap * 4;
    int startY = (int)((this.ClientSize.Height - totalHeight) / 2.5);
    int buttonStartX = (this.ClientSize.Width - buttonWidth - gap) / 2;
    int buttonStartY = startY + labelHeight + gap * 2;

    // Create the title label
    titleLabel = new Label
    {
        Text = "Brick Breaker",
        Font = fontFamily != null ? new Font(fontFamily, 48, FontStyle.Regular) : new Font("Arial", 10, FontStyle.Regular),
        ForeColor = Color.White,
        BackColor = Color.FromArgb(30, 32, 40),
        TextAlign = ContentAlignment.MiddleCenter,
        AutoSize = false,
        Size = new Size(labelWidth, labelHeight),
        Location = new Point((this.ClientSize.Width - labelWidth) / 2, startY)
    };
    this.Controls.Add(titleLabel);

    // Create the buttons
    startButton = CreateButton("Start", Properties.Resources.pinkBrick, buttonWidth, buttonHeight,
        buttonStartX, buttonStartY, (sender, e) =>
        {
            form.Invoke(new MethodInvoker(() => form.StartGame())); // When "Start" is clicked, the StartGame method from Form1 is executed
        });

    demoButton = CreateButton("Demo", Properties.Resources.orangeBrick, buttonWidth, buttonHeight,
        buttonStartX, buttonStartY + buttonHeight + gap, (sender, e) =>
        {
            form.Invoke(new MethodInvoker(() => form.StartDemo())); // Similarly, "Demo" launches the demo mode
        });

    exitButton = CreateButton("Exit", Properties.Resources.greenBrick, buttonWidth, buttonHeight,
        buttonStartX, buttonStartY + (buttonHeight + gap) * 2, (sender, e) =>
        {
            form.Invoke(new MethodInvoker(() => form.Close())); // The "Exit" button closes the application
        });

    // Add the buttons to the panel
    this.Controls.Add(startButton);
    this.Controls.Add(demoButton);
    this.Controls.Add(exitButton);
}
```


#### LoadCustomFont method
This method was created because I used a font that is not available by default in Windows Forms, more on copyright in the last Chapter. An application built with a font installed only on my computer would not work properly on another device. I couldn’t imagine forcing the user to download a font before running the application, so the font file was added directly to the project files.

To make everything work correctly, it was also necessary to create a special method to handle the font. Personally, this was one of the more challenging methods for me to write, as finding a working solution online and successfully applying it to my application proved to be quite demanding.
```C#
private void LoadCustomFont() // Method allowing the use of a font from project files
{
    string fontPath = Path.Combine(Application.StartupPath, "A Goblin Appears!.otf");
    if (File.Exists(fontPath)) // Check if the path exists
    {
        PrivateFontCollection fontCollection = new PrivateFontCollection();
        fontCollection.AddFontFile(fontPath);
        fontFamily = fontCollection.Families[0];
    }
    else
    {
        MessageBox.Show("Font didn't load properly"); // If it doesn't exist, show a message
    }
}
```


### Game Objects
I consider the classes used to create game objects to be the strongest part of the project from an object-oriented perspective. They make use of the four fundamental principles of OOP:

* **Encapsulation** – The properties and methods of each class are defined as either private or public, which restricts access to internal class data and ensures better code organization.
* **Inheritance** – All objects inherit from the base class `GameObjects`, which improves extensibility and eliminates the need to duplicate code (objects share common features such as `width`, `height`, and the `Draw` method).
* **Polymorphism** – The derived classes override the `Move` method, each providing its own unique implementation.
* **Abstraction** – The `GameObjects` class serves as the abstract base for all game elements. Additionally, the `Move` method itself is abstract, enforcing its implementation in every subclass.


#### Printing Objects
In addition to the functionalities discussed in the previous subsection, it is also worth mentioning the `Draw` and `UpdateBoundaries` methods. The objects I create are dynamic, which means I cannot implement them in the standard way (e.g., as a `PictureBox`), since such an approach leads to various issues like flickering or visible white edges. A much better practice is to render objects using the `Draw` method, which relies on a `Graphics` object passed as an argument.

Rendering objects in this manner is more dynamic, consumes fewer resources, and provides greater flexibility when creating multiple objects or manipulating their positions.
```C#
public abstract class GameObject // Base class for all objects, defining their basic properties
{
    public int x { get; set; } // X position
    public int y { get; set; } // Y position
    public int width { get; set; } // Object width
    public int height { get; set; } // Object height
    public Image objectImage { get; set; } // Object image

    // Default form boundaries
    public static int boundaryWidth { get; set; } = 821;
    public static int boundaryHeight { get; set; } = 700;

    public GameObject(int x, int y, int width, int height, Image image)
    {
        this.x = x; // Set X position
        this.y = y; // Set Y position
        this.width = width; // Set width
        this.height = height; // Set height
        objectImage = image; // Set image
    }

    public abstract void Move(); // Abstract Move method, each object has its own logic here

    public virtual void Draw(Graphics g) // Method checks if the object has an assigned image and draws it
    {
        if (objectImage != null)
        {
            g.DrawImage(objectImage, new Rectangle(x, y, width, height));
        }
    }
}
```


#### Paddle
The most important mechanic in the paddle-handling class is its movement. The `SetVelocity` method allows setting the target movement speed to the left or right. However, it never directly changes the object’s final position—instead, it only influences its gradual update, which is carried out by the `Move` method.

All of this is achieved using the following formula:
```C#
currentVelocity += (targetVelocity - currentVelocity) * 0.2f;
x += (int)currentVelocity;
```
Another aspect I would like to discuss is preventing the player from moving the paddle outside the boundaries of the form.
```C#
// Prevent the paddle from going beyond the left boundary
if (x < 0)
    x = 0;

// Prevent the paddle from going beyond the right boundary
if (x + width > GameObject.boundaryWidth)
    x = GameObject.boundaryWidth - width;
```


#### Ball
Handling the ball’s movement is slightly more complex than managing the paddle, as it requires implementing collision mechanics, direction changes, and speed adjustments. At the beginning I define two fields representing the velocities along the X and Y axes, which are updated each time the method is called. These velocities are randomized within a certain range, adding more dynamism to the game.

In the main movement-handling method, the ball’s position is updated based on its velocity. Similar to the paddle, I also prevent the ball from leaving the boundaries of the form. The key difference, however, is that when the ball collides with any edge, its direction is reversed.
```C#
// Check for collisions with the walls
if (x <= 0 || x + width >= GameObject.boundaryWidth)
{
    velocityX *= -1; // Bounce off the left or right wall, reversing the ball's direction
}
if (y <= 0)  // Bounce off the top boundary has the same effect
{
    velocityY *= -1;
}
```
I also create the public method that changes ball direction in order to use it in class responsible for game logic.


#### Brick
A brick is not a moving object, so I focused only on creating a field that indicates whether the brick has already been destroyed. I also added a randomizer inside the constructor to assign images to each brick randomly.



### Game Mechanics
#### CollisionManager
The class is responsible for detecting collisions between game objects and implementing the logic that handles them. It iterates over the list of bricks to check whether the ball has touched any of them, and if so, marks the brick as destroyed.

At first, it might seem unusual that part of the collision mechanics is handled within the `GameObjects` region and part within a separate class. However, this approach is intentional. The strategy supports encapsulation and makes the code easier to maintain, ensuring that each class is responsible only for its own functionality (SRP – Single Responsibility Principle).

In summary, the `CollisionManager` serves as the central hub for handling collisions, while `GameObjects` contains the methods that determine what happens after a collision occurs.
```C#
// Ball-paddle collision, considering three conditions:
if (game.ball.y + game.ball.height >= game.paddle.y &&
    game.ball.x + game.ball.width >= game.paddle.x &&
    game.ball.x <= game.paddle.x + game.paddle.width)
{
    game.ball.Bounce(); // Bounce the ball off the paddle
}

// Ball-brick collisions. Iterate through all bricks and check for collisions with the ball
foreach (var brick in game.bricks)
{
    if (!brick.isDestroyed &&
        game.ball.x + game.ball.width > brick.x &&
        game.ball.x < brick.x + brick.width &&
        game.ball.y + game.ball.height > brick.y &&
        game.ball.y < brick.y + brick.height)
    {
        game.ball.Bounce(); // Bounce the ball off the brick
        brick.Destroy(); // Destroy the brick
    }
}
```


#### InputManager
A public class responsible for handling user input. It enables keyboard-based controls when the player presses a movement key, the paddle’s velocity increases in the corresponding direction, updating its position accordingly.

I put special attention to the paddle control in demo mode. In this mode, the paddle automatically tracks the ball’s movement by shifting whenever the X-coordinates of their centers do not match.
```C#
public void HandleDemoMovement() // Handles demo mode where the paddle follows the ball along the X axis
{
    int demoSpeed = GameConstants.paddleSpeed - 3; // Paddle speed in demo mode (slightly slower)
    int paddleCenter = game.paddle.x + game.paddle.width / 2;
    int ballCenter = game.ball.x + game.ball.width / 2;

    if (paddleCenter < ballCenter - 5)
        game.paddle.SetVelocity(demoSpeed); // If paddle center is left of the ball, move paddle right
    else if (paddleCenter > ballCenter + 5)
        game.paddle.SetVelocity(-demoSpeed); // If paddle center is right of the ball, move paddle left
    else
        game.paddle.SetVelocity(0); // If paddle center aligns with ball center, stop the paddle
}
```


### Game Class
#### Start Method
The `Start` method is an initialization method in which all movable objects and bricks are created. It also sets up and starts the timer—the most crucial component for running the game. This method is called each time the player starts a new game.


#### TimerTick
A method responsible for the main game loop, which initializes and manages the previously implemented mechanics such as collisions, speed, and movement.
```C#
private void Timer_Tick(object sender, EventArgs e) // Timer actions
{
    ball.Move(); // Handle the ball's movement

    if (isDemoMode)
        InputManager.HandleDemoMovement(); // If demo mode is active, use the automated paddle movement

    paddle.Move(); // Handle the paddle's movement
    CollisionManager.CheckCollisions(); // Check collisions
    GameLostCheck(); // Verify if the game is lost
    GameWonCheck(); // Verify if the game is won
    view.Invalidate(); // Refresh the game view
}
```


#### End of Game
The end of game event is handled through five interrelated methods. The most important are `GameWonCheck` and `GameLostCheck`, which verify whether all the blocks have been destroyed or if the ball has fallen below the bottom edge of the screen. In both cases, the `EndGame` method is triggered, stopping the timer and marking the game as inactive.

Additionally, methods are called to display windows informing the player of a win or loss (including in demo mode). Finally, regardless of the reason the game ended, the player has the option to start a new game or return to the main menu.



### Output
https://github.com/user-attachments/assets/c4d70417-af7b-41c0-a52b-5f9cb860ba43



### Copyrights
All graphics used in the program (background, ball, paddle, bricks) were created by me using free graphic software.

The font used in the program does not belong to me and was used under a free license for non-commercial use. The font was created by Allison J. James and Daniel Johnston Menezes. For more information about their work, please visit the [authors’ website](https://www.fontspace.com/chequered-ink).
